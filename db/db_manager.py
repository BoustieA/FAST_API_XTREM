import os

from sqlalchemy import create_engine, inspect
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from logger.logger_manager import LoggerManager

Base = declarative_base()


class DBManager:
    def __init__(self, database_url: str = "sqlite:///./database.db", logger=None):
        """
        Initialise le gestionnaire de base de donn√©es

        Args:
            database_url: URL de connexion √† la base de donn√©es SQLite
            logger: Instance du gestionnaire de logs
        """
        self.database_url = database_url
        self.engine = None
        self.SessionLocal = None
        self.logger = logger or LoggerManager()
        self._check_db_file()

    def _check_db_file(self):
        """V√©rifie si le fichier de base de donn√©es existe, l'extrait de l'URL SQLite"""
        if self.database_url.startswith("sqlite:///"):
            # Extraire le chemin du fichier de la cha√Æne de connexion SQLite
            db_file = self.database_url.replace("sqlite:///", "")

            # Assurez-vous que le r√©pertoire parent existe
            db_dir = os.path.dirname(db_file)
            if db_dir and not os.path.exists(db_dir):
                os.makedirs(db_dir)
                self.logger.info(f"Cr√©ation du r√©pertoire pour la base de donn√©es: {db_dir}")

            db_exists = os.path.exists(db_file)

            if db_exists:
                self.logger.info(f"Utilisation de la base de donn√©es existante: {db_file}")
            else:
                self.logger.info(f"Le fichier de base de donn√©es sera cr√©√©: {db_file}")

    def connect(self):
        """√âtablit la connexion √† la base de donn√©es SQLite"""
        try:
            self.logger.info(f"Tentative de connexion √†: {self.database_url}")
            self.engine = create_engine(
                self.database_url,
                connect_args={"check_same_thread": False}  # N√©cessaire pour SQLite
            )

            # Cr√©ation des tables si elles n'existent pas
            Base.metadata.create_all(bind=self.engine)

            self.SessionLocal = sessionmaker(
                autocommit=False,
                autoflush=False,
                bind=self.engine
            )

            # V√©rification que la connexion fonctionne
            with self.engine.connect() as conn:
                with conn.begin():
                    pass

            self.logger.success(f"‚úÖ Connect√© √† la base de donn√©es: {self.database_url}")
            return True

        except Exception as e:
            self.logger.error(f"‚ùå Erreur de connexion √† la base de donn√©es: {str(e)}")
            raise

    def disconnect(self):
        """Ferme proprement la connexion √† la base de donn√©es"""
        if self.engine:
            self.engine.dispose()
            self.logger.info("üîå D√©connexion de la base de donn√©es effectu√©e")
        else:
            self.logger.warning("Tentative de d√©connexion sans connexion active")

    def get_db(self):
        """Fournit une session de base de donn√©es pour les d√©pendances FastAPI"""
        if not self.SessionLocal:
            self.logger.error("Tentative d'obtenir une session sans connexion active")
            raise Exception("Base de donn√©es non connect√©e")

        db = self.SessionLocal()
        try:
            yield db
        finally:
            db.close()

    def check_tables(self):
        """V√©rifie les tables existantes dans la base de donn√©es"""
        if not self.engine:
            self.logger.error("Impossible de v√©rifier les tables sans connexion active")
            return []

        inspector = inspect(self.engine)
        tables = inspector.get_table_names()
        if tables:
            self.logger.info(f"Tables existantes: {', '.join(tables)}")
        else:
            self.logger.info("Aucune table n'existe encore dans la base de donn√©es")
        return tables

# Suppression de la fonction lifespan qui n'est plus n√©cessaire ici